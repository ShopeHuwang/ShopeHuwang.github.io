<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <meta name="theme-color" content="#34495e">
  <title>Java 并发编程 | Shope</title>
  <link rel="alternate" href="path/of/rss" type="application/atom+xml">
  <link rel="shortcut icon" type="image/ico" href="/favicon.ico">
  
<link rel="stylesheet" href="/css/style.css">

  

  

  

  

<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div class="mobile-header">
    <span><i class="iconfont icon-turnon" id="mobile-nav-toggle"></i></span>
    <div class="mobile-logo">
      <a href="/.">Shope Huwang</a>
    </div>
  </div>
  <div class="page" id="mobile-nav-panel">
    <div class="container">
      <header class="site-nav">
      <div class="nav-content">
        <div class="logo">
          <a href="/">Shope Huwang</a>
        </div>
        <nav class="navbar">
          <ul>
            
              <li class="menu-item">
                <a href="/" class="menu-item-link"><i class="iconfont icon-home"></i>首页</a>
              </li>
            
              <li class="menu-item">
                <a href="/archives/" class="menu-item-link"><i class="iconfont icon-archive"></i>归档</a>
              </li>
            
              <li class="menu-item">
                <a href="/about/" class="menu-item-link"><i class="iconfont icon-about"></i>关于</a>
              </li>
            
          </ul>
        </nav>
      </div>
</header>

      <div class="banner">
  <div class="show">
    <!-- <img src="/" alt="banner"> -->
    <div class="banner-title">
      
        <div class="post-title">
          Java 并发编程
            <div class="post-tags">
    		    
              <a class="tag-none-link" href="/tags/BlockQueue/" rel="tag">BlockQueue</a> <a class="tag-none-link" href="/tags/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" rel="tag">Java 并发编程</a> <a class="tag-none-link" href="/tags/ThreadPool/" rel="tag">ThreadPool</a>
            
    	      </div>
        </div>
      
    </div>
  </div>
</div>

      <main class="main"id="main">
          <article class="post">
  

  <header>
    <div class="post-title mobile-post-title">
      <h1>Java 并发编程</h1>
        <div class="post-tags">
        
          <a class="tag-none-link" href="/tags/BlockQueue/" rel="tag">BlockQueue</a> <a class="tag-none-link" href="/tags/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" rel="tag">Java 并发编程</a> <a class="tag-none-link" href="/tags/ThreadPool/" rel="tag">ThreadPool</a>
        
        </div>
    </div>
    <div class="post-meta">
      <span class="post-time"><i class="iconfont icon-calendar"></i>2020-11-19</span>
      
      <!----------------------------------->
        
      <!----------------------------------->
    </div>
  </header>
  
  <div class="post-toc" id="post-toc">
    <h2 class="post-toc-title">目录</h2>
    <div class="post-toc-content">
      <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%89%B9%E6%80%A7%EF%BC%9A"><span class="toc-text">并发编程特性：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8B%E5%8D%B3%E4%BD%BF%E4%B8%8D%E5%8A%A0volatile%E4%B9%9F%E4%BC%9A%E5%8F%AF%E8%A7%81%E7%9A%84%E5%8E%9F%E5%9B%A0%EF%BC%9A"><span class="toc-text">多线程下即使不加volatile也会可见的原因：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90"><span class="toc-text">逃逸分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%81%E7%9A%84%E7%B2%97%E5%8C%96"><span class="toc-text">锁的粗化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%81%E7%9A%84%E6%B6%88%E9%99%A4"><span class="toc-text">锁的消除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AQS"><span class="toc-text">AQS</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#queue%E9%98%9F%E5%88%97"><span class="toc-text">queue队列</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ReentrantLock"><span class="toc-text">ReentrantLock</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BlockQueue"><span class="toc-text">BlockQueue</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%844%E7%A7%8D%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97"><span class="toc-text">常见的4种阻塞队列</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CountDownLatch-amp-Semaphore"><span class="toc-text">CountDownLatch &amp; Semaphore</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Semaphore"><span class="toc-text">Semaphore</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CountDownLatch"><span class="toc-text">CountDownLatch</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CyclicBarrier"><span class="toc-text">CyclicBarrier</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ThreadPool"><span class="toc-text">ThreadPool</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ThreadPoolExecutor"><span class="toc-text">ThreadPoolExecutor</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ScheduleThreadPoolExecutor"><span class="toc-text">ScheduleThreadPoolExecutor</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%87%87%E7%94%A8DelayQueue%E5%AD%98%E5%82%A8%E7%AD%89%E5%BE%85%E7%9A%84%E4%BB%BB%E5%8A%A1"><span class="toc-text">采用DelayQueue存储等待的任务</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#SchduledFutureTask-SchduledFutureTask%E6%8E%A5%E6%94%B6%E7%9A%84%E5%8F%82%E6%95%B0-%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F-%EF%BC%9A"><span class="toc-text">SchduledFutureTask SchduledFutureTask接收的参数(成员变量)：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%EF%BC%9A"><span class="toc-text">工作线程的执行过程：</span></a></li></ol></li></ol></li></ol>
    </div>
  </div>


  <div class="post-content">
    <h3 id="并发编程特性："><a href="#并发编程特性：" class="headerlink" title="并发编程特性："></a>并发编程特性：</h3><p>1、可见性–volatile解决可见性问题（确保变化及时可见）</p>
<p>2、原子性–加锁</p>
<p>3、有序性</p>
<p>volatile：Java并发中轻量级的锁机制</p>
<h3 id="多线程下即使不加volatile也会可见的原因："><a href="#多线程下即使不加volatile也会可见的原因：" class="headerlink" title="多线程下即使不加volatile也会可见的原因："></a>多线程下即使不加volatile也会可见的原因：</h3><p>1、因为在OS执行程序时，如果的CPU运行时间片结束了，会保存当前运行状态，然后CPU就会切换给其他线程去使用，等到再次拿到时间片后，OS会从继续恢复执行，此时变量已经被改变了。</p>
<p>2、可能是缓存行（cacheline）更新，会从内存中去读取新的值。</p>
<p>3、根据<strong>时间局限性</strong>或者<strong>空间局限性</strong>缓存原理，读取到新的值。</p>
<p>volatile禁止重排优化：</p>
<p>volatile可以禁止指令重排优化，避免多线程环境下出现乱序执行的现象。</p>
<h3 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h3><p>分析一个对象动态的作用域，如果一个对象通过方法参数传递到其他方法中，称为方法逃逸；赋值的类变量被其他线程访问到，称为线程逃逸。</p>
<p>防止逃逸：</p>
<p>1、栈上分配    2、同步取消    3、标量替换</p>
<h3 id="锁的粗化"><a href="#锁的粗化" class="headerlink" title="锁的粗化"></a>锁的粗化</h3><p>为了确保共享数据在共同作用域时，只在实际作用作用域中进行同步，这样是为了使得同步操作数量尽可能变小，如果存在锁的竞争，那么锁在线程就能尽快获得锁。但是如果一系列的连续操作都对同一个对象反复加锁和解锁，JVM就会对这样的代码进行优化成只需要加一次锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">  <span class="comment">// 语句 1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">  <span class="comment">// 语句 2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//	优化后变成</span></span><br><span class="line"><span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">  <span class="comment">// 语句 1</span></span><br><span class="line">  <span class="comment">// 语句 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="锁的消除"><a href="#锁的消除" class="headerlink" title="锁的消除"></a>锁的消除</h3><p>锁削除是指虚拟机即时编译器在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁，对其进行消除。因为没有竞争条件，同步只会导致性能下降，所以JVM会是使用”<strong>逃逸分析</strong>“，分析如果没有发生逃逸，则会将同步锁清除，提升代码质量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">do</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">synchronized</span>(obj)&#123;</span><br><span class="line">		<span class="comment">//	TODO</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h3><p>Abstract Queued Synchronizer–抽象队列同步器</p>
<p>特性：</p>
<ul>
<li>阻塞等待队列</li>
<li>共享/独占</li>
<li>公平/非公平</li>
<li>可重入</li>
<li>可中断</li>
</ul>
<p><strong>原理：自旋、LockSuport、CAS、queue队列。</strong></p>
<p>当线程抢锁的时候会先判断当前线程是不是已经获得锁，如果已经获得过锁，那么<strong>state+1</strong>（将state+1表示当前线程再次获取到锁，释放锁则将state-1，直到state=0表示锁完全被释放），进入到阻塞代码块中，否则让线程进入到阻塞队列中，为确保入队成功，在入队时操作是进行自旋—-CAS，直到成功添加到<strong>queue</strong>队列中，如果<strong>Node</strong>是队列中的<strong>第一个Node</strong>，在入队后还要对锁进行一次抢夺：</p>
<p>​    如果获取锁成功：出队，将head设置为当前Node并将thread设置为空—-表示head节点；</p>
<p>​    如果获取锁失败：1、修改head的状态（<strong>waitStatus</strong>） 2、使用LockSuport阻塞线程，并判断线程是否是被唤醒的(在非公平模式下，唤醒后可能获取不到锁)</p>
<p>​    修改<strong>head</strong>的<strong>waitStatus</strong>：0-&gt;-1，</p>
<h4 id="queue队列"><a href="#queue队列" class="headerlink" title="queue队列"></a>queue队列</h4><p>是一个双向链表队列，queue的节点信息由Node存储。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">	Node pre;	<span class="comment">// 上一个节点</span></span><br><span class="line">	Node next;	<span class="comment">// 下一个节点</span></span><br><span class="line">	<span class="keyword">int</span> waitStatus;</span><br><span class="line">     	<span class="comment">/* Status field, taking on only the values:</span></span><br><span class="line"><span class="comment">         *   SIGNAL: 	-1	可被唤醒</span></span><br><span class="line"><span class="comment">         *   CANCELLED:  1	代表出现异常，中断引起的</span></span><br><span class="line"><span class="comment">         *   CONDITION: -2	条件等待</span></span><br><span class="line"><span class="comment">         *   PROPAGATE: -3	传播</span></span><br><span class="line"><span class="comment">         *   0:  			初始状态</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROPAGATE = -<span class="number">3</span>;</span><br><span class="line">	Thread thread;	<span class="comment">// 记录节点中的线程引用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h3><p>在java.util.concurrent.locks;</p>
<p>ReentrantLock是一种居于AQS框架的应用实现，是JDK中的一种线程并发访问的同步手段，他的功能类似于synchronized是一种互斥锁，可以保证线程安全。而且它具有比synchronized更多的特性，比如它支持手动加锁与解锁，支持加锁的公平性。</p>
<p><img src="https://i.loli.net/2020/11/20/FTkaVKodCtg1upm.png" alt="ReentrantLock_Class_Relation.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//	使用ReentrantLock进行同步</span></span><br><span class="line">ReentrantLock lock = <span class="keyword">new</span> ReentrantLock(<span class="keyword">false</span>); <span class="comment">// false 为非公平锁，true为公平锁</span></span><br><span class="line">lock.lock();	<span class="comment">//	加锁</span></span><br><span class="line">lock.unlock();	<span class="comment">//	解锁</span></span><br></pre></td></tr></table></figure>

<p><strong>ReentrantLock</strong>内部定义了一个<strong>Sync内部类</strong>，该类继承<strong>AbstractQueuedSynchronizer</strong>，对该抽象类的部分方法做了实现：定义了<strong>两个子类</strong>：</p>
<p>​        <strong>1、FairSync 公平锁的实现</strong></p>
<p>​        <strong>2、NonFairSync 非公平锁的实现</strong></p>
<p>这些类都继承自Sync，也就是间接继承了AbstractQueueSybchronizer，所以ReentrantLock同时具备公平与非公平特性。</p>
<p><font color="red">*</font> **interrupt()**方法会将线程的中断信号清楚，并返回中断状态，这也就意味着线程会进入运行状态。</p>
<h3 id="BlockQueue"><a href="#BlockQueue" class="headerlink" title="BlockQueue"></a>BlockQueue</h3><p>BlockingQueue，是java.util.concurrent 包提供的用于解决<strong>并发生产者 - 消费者问题</strong>的最有用的类，它的特性是在任意时刻只有一个线程可以进行take或者put操作，并且 BlockingQueue提供了超时return null的机制，在许多生产场景里都可以看到这个工具的 身影。</p>
<h4 id="常见的4种阻塞队列"><a href="#常见的4种阻塞队列" class="headerlink" title="常见的4种阻塞队列"></a>常见的4种阻塞队列</h4><ol>
<li>ArrayBlockingQueue 由数组支持的有界队列 </li>
<li>LinkedBlockingQueue 由链接节点支持的可选有界队列 </li>
<li>PriorityBlockingQueue 由优先级堆支持的无界优先级队列 </li>
<li>DelayQueue 由优先级堆支持的、基于时间的调度队列</li>
</ol>
<h3 id="CountDownLatch-amp-Semaphore"><a href="#CountDownLatch-amp-Semaphore" class="headerlink" title="CountDownLatch &amp; Semaphore"></a>CountDownLatch &amp; Semaphore</h3><h4 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h4><p>字面意思是信号量的意思，它的作用是控制访问特定资源的线程数目，底层依赖<strong>AQS</strong>的状态State，是在生产当中比较常用的一个工具类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits, <span class="keyword">boolean</span> fair)</span></span></span><br><span class="line"><span class="function"><span class="comment">//	permits 表示许可线程的数量</span></span></span><br><span class="line"><span class="function"><span class="comment">//	fair	如果为true，下次执行等待最久的线程。如果为false，线程间会进行抢夺，谁抢到执行谁</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="comment">//	表示阻塞并获取许可</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span></span><br><span class="line"><span class="function"><span class="comment">//	表示释放许可</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="comment">//	例子</span></span></span><br><span class="line"><span class="function">    <span class="comment">//	每次自能有两个线程同时运行</span></span></span><br><span class="line"><span class="function">    Semaphore s </span>= <span class="keyword">new</span> Semaphore(<span class="number">2</span>); </span><br><span class="line">	s.acquire(); <span class="comment">//	会将资源 status!=0,status-1,</span></span><br><span class="line">	s.release(); <span class="comment">//	返还资源 status+1</span></span><br></pre></td></tr></table></figure>

<p>应用：Hystrix里限流就是基于信号量方式；</p>
<h4 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h4><p>​    CountDownLatch是通过一个计数器来实现的，计数器的初始值为线程的数量。每当一个线程完成了自己的任务后，计数器的值就会减1。当计数器的值为0时，表示所有线程执行完任务，然后在闭锁上等待的线程就可以恢复执行任务。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">countDownLatch.countDown(); <span class="comment">//	每调用一次 计数器的值减1 ，直到为0</span></span><br><span class="line"></span><br><span class="line">countDownLatch.await();	<span class="comment">//	等待2个子线程执行完毕，否则一直阻塞</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h4><p>​    栅栏屏障，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程 到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续运行。 </p>
<p>​    CyclicBarrier默认的构造方法是<strong>CyclicBarrier（int parties）</strong>，其参数表示屏障拦截的线程数量，每个线程调用await方法告CyclicBarrier我已经到达了屏障，然后当前线程被阻塞。</p>
<hr>
<h3 id="ThreadPool"><a href="#ThreadPool" class="headerlink" title="ThreadPool"></a>ThreadPool</h3><p><strong>使⽤线程池主要有以下三个原因：</strong> </p>
<ol>
<li>创建/销毁线程需要消耗系统资源，线程池可以复⽤已创建的线程。 </li>
<li>控制并发的数量。并发数量过多，可能会导致资源消耗过多，从⽽造成服务器 崩溃。</li>
<li>可以对线程做统⼀管理。</li>
</ol>
<h4 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 五个参数的构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params"> <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params"> <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params"> TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params"> BlockingQueue&lt;Runnable&gt; workQueue)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 六个参数的构造函数-1</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params"> <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params"> <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params"> TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params"> BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params"> ThreadFactory threadFactory)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 六个参数的构造函数-2</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params"> <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params"> <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params"> TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params"> BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params"> RejectedExecutionHandler handler)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 七个参数的构造函数</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params"> <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params"> <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params"> TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params"> BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params"> ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params"> RejectedExecutionHandler handler)</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>int corePoolSize</strong>：该线程池中核⼼线程数最⼤值</p>
<p>线程池中有两类线程，核心线程与非核心线程。核心线程<strong>默认情况</strong>下回一直存在与线程中，不回被销毁，而非核心线程如果长时间闲置，就会被销毁。</p>
</li>
<li><p><strong>int maximumPoolSize</strong>：该线程池中线程总数最⼤值 。<br>$$<br>maximumPoolSize=核⼼线程数量 + ⾮核⼼线程数量<br>$$</p>
</li>
<li><p><strong>long keepAliveTime</strong>：⾮核⼼线程闲置超时时⻓。</p>
<p>⾮核⼼线程如果处于闲置状态超过该值，就会被销毁。如果设置 **allowCoreThreadTimeOut(<font color="red">true</font>)**，则会也作⽤于核⼼线程。</p>
</li>
<li><p><strong>RejectedExecutionHandler handler</strong> 拒绝处理策略，线程数量⼤于最⼤线程数就会采⽤拒绝处理策略，</p>
<p>四种拒绝处理的策略为 ：</p>
<ol>
<li><p>ThreadPoolExecutor.<strong>AbortPolicy</strong>：默认拒绝处理策略，丢弃任务并抛RejectedExecutionException异常。 </p>
</li>
<li><p>ThreadPoolExecutor.<strong>DiscardPolicy</strong>：丢弃新来的任务，但是不抛出异常。 </p>
</li>
<li><p>ThreadPoolExecutor.<strong>DiscardOldestPolicy</strong>：丢弃队列头部（最旧的） 的任务，然后重新尝试执⾏程序（如果再次失败，重复此过程）。</p>
</li>
<li><p>ThreadPoolExecutor.<strong>CallerRunsPolicy</strong>：由调⽤线程处理该任务。</p>
</li>
</ol>
</li>
</ul>
<h4 id="ScheduleThreadPoolExecutor"><a href="#ScheduleThreadPoolExecutor" class="headerlink" title="ScheduleThreadPoolExecutor"></a>ScheduleThreadPoolExecutor</h4><p><strong>定时线程池类的类结构图</strong></p>
<p><img src="https://i.loli.net/2020/11/20/2QoOsk7ZEhapnRc.png" alt="ScheduledExecutorService_Class_Relationship.jpg"></p>
<p>接收SchduledFutureTask类型的任务，是线程池调度任务的最小单位，有三种提交任务的方式： </p>
<ul>
<li>schedule 提交一次性任务</li>
<li>cheduledAtFixedRate  提交周期性任务（固定速率提交，延迟时间一到就提交）</li>
<li>scheduledWithFixedDelay 提交周期性任务（固定延迟提交，等待上一次任务执行完成后在延迟提交）</li>
</ul>
<h5 id="采用DelayQueue存储等待的任务"><a href="#采用DelayQueue存储等待的任务" class="headerlink" title="采用DelayQueue存储等待的任务"></a>采用DelayQueue存储等待的任务</h5><ol>
<li>DelayQueue内部封装了一个PriorityQueue，它会根据time的先后时间排序，若 time相同则根据sequenceNumber排序； </li>
<li>DelayQueue也是一个无界队列；</li>
</ol>
<h5 id="SchduledFutureTask-SchduledFutureTask接收的参数-成员变量-："><a href="#SchduledFutureTask-SchduledFutureTask接收的参数-成员变量-：" class="headerlink" title="SchduledFutureTask SchduledFutureTask接收的参数(成员变量)："></a>SchduledFutureTask SchduledFutureTask接收的参数(成员变量)：</h5><ol>
<li>private long time：任务开始的时间 </li>
<li>private final long sequenceNumber：任务的序号 </li>
<li>private final long period：任务执行的时间间隔</li>
</ol>
<h5 id="工作线程的执行过程："><a href="#工作线程的执行过程：" class="headerlink" title="工作线程的执行过程："></a>工作线程的执行过程：</h5><ul>
<li>工作线程会从DelayQueue取已经到期的任务去执行； </li>
<li>执行结束后重新设置任务的到期时间，再次放回DelayQueue;</li>
</ul>
<p><strong>ScheduledThreadPoolExecutor</strong>会把待执行的任务放到工作队列<strong>DelayQueue</strong>中， DelayQueue封装了一个<strong>PriorityQueue</strong>，PriorityQueue会对队列中的 <strong>ScheduledFutureTask</strong>进行排序，具体的排序算法实现如下：</p>
<ol>
<li>首先按照<strong>time</strong>排序，time小的排在前面，time大的排在后面； </li>
<li>如果time相同，按照<strong>sequenceNumber</strong>排序，sequenceNumber小的排在前 面，sequenceNumber大的排在后面，换句话说，如果两个task的执行时间相同， 优先执行先提交的task。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Delayed other)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">if</span> (other == <span class="keyword">this</span>) <span class="comment">// compare zero if same object</span></span><br><span class="line">               <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">           <span class="keyword">if</span> (other <span class="keyword">instanceof</span> ScheduledFutureTask) &#123;</span><br><span class="line">               ScheduledFutureTask&lt;?&gt; x = (ScheduledFutureTask&lt;?&gt;)other;</span><br><span class="line">               <span class="keyword">long</span> diff = time - x.time;</span><br><span class="line">               <span class="keyword">if</span> (diff &lt; <span class="number">0</span>)</span><br><span class="line">                   <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">               <span class="keyword">else</span> <span class="keyword">if</span> (diff &gt; <span class="number">0</span>)</span><br><span class="line">                   <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">               <span class="keyword">else</span> <span class="keyword">if</span> (sequenceNumber &lt; x.sequenceNumber)</span><br><span class="line">                   <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">               <span class="keyword">else</span></span><br><span class="line">                   <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">long</span> diff = getDelay(NANOSECONDS) - other.getDelay(NANOSECONDS);va</span><br><span class="line">           <span class="keyword">return</span> (diff &lt; <span class="number">0</span>) ? -<span class="number">1</span> : (diff &gt; <span class="number">0</span>) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<p><strong>ScheduledFutureTask之run方法实现 run方法是调度task的核心，task的执行实际上是run方法的执行。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Overrides FutureTask version so as to reset/requeue if periodic.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> periodic = isPeriodic();</span><br><span class="line">    <span class="comment">//	如果当前线程池不执行任务，则取消</span></span><br><span class="line">    <span class="keyword">if</span> (!canRunInCurrentRunState(periodic))</span><br><span class="line">        cancel(<span class="keyword">false</span>);</span><br><span class="line">    <span class="comment">//	如果不需要周期执行，则直接执行run方法，最后结束</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!periodic)</span><br><span class="line">        ScheduledFutureTask.<span class="keyword">super</span>.run();</span><br><span class="line">    <span class="comment">//	如果需要周期执行，则在执行完任务以后，设置下一次执行时间</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (ScheduledFutureTask.<span class="keyword">super</span>.runAndReset()) &#123;</span><br><span class="line">        <span class="comment">//	计算并设置下次执行该任务的时间</span></span><br><span class="line">        setNextRunTime();</span><br><span class="line">        <span class="comment">//	重复执行任务</span></span><br><span class="line">        reExecutePeriodic(outerTask);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


  </div>
  <div class="post-footer">the end</div>
</article>

          
  <nav class="pagination post-nav">
    
      <a href="/2020/11/26/2020-11-26-MySQL/">
        <span class="prev-post"><i class="iconfont icon-back"></i>MySQL</span>
      </a>
    
    
      <a href="/2020/11/18/2020-11-18-JVM/">
        <span class="next-post">JVM<i class="iconfont icon-more"></i></span>
      </a>
    
  </nav>


          
  


      </main>
    </div>
    <footer>
      <div class="social-links">
        
          
            <a target="_blank" rel="noopener" href="https://www.zhihu.com/"><i class="iconfont icon-zhihu"></i></a>
          
        
          
            <a target="_blank" rel="noopener" href="https://weibo.com"><i class="iconfont icon-weibo"></i></a>
          
        
          
            <a target="_blank" rel="noopener" href="https://github.com/"><i class="iconfont icon-github"></i></a>
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
      </div>
      
        <div class="quote">
          <p>Love all, trust a few, do wrong to none.——William Shakespeare</p>
        </div>
      
      <div class="copyright">
        <p>
          由 <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a> 强力驱动
          <span>|</span>
          主题 - <a target="_blank" rel="noopener" href="https://github.com/wa-ri/hexo-theme-ztopic">ztopic</a
        </p>
        <p>
          <span>
          
          &copy;
          
            2021
          
          </span>
          <i class="iconfont icon-circle"></i>
          <span>Shope Huwang</span>
        </p>
      </div>
</footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <div id="mobile-nav">
  <nav id="mobile-nav-menu">
    
      <a href="/" class="mobile-nav-link"><i class="iconfont icon-home"></i>首页</a>
    
      <a href="/archives/" class="mobile-nav-link"><i class="iconfont icon-archive"></i>归档</a>
    
      <a href="/about/" class="mobile-nav-link"><i class="iconfont icon-about"></i>关于</a>
    
    <div class="mobile-intro"><i class="iconfont icon-pen"></i>You&#39;ll shine like a diamond</div>
  </nav>
</div>


  
<script src="/libs/jQuery/jquery-3.2.1.min.js"></script>

  
<script src="/libs/slideout/slideout.min.js"></script>

  
    
<link rel="stylesheet" href="/libs/fancybox/jquery.fancybox.css">

    
<script src="/libs/fancybox/jquery.fancybox.pack.js"></script>

  
  

  
<script src="/js/ztopic.js"></script>

</body>
</html>
